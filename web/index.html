<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenSite Pipeline Monitor</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; margin: 0; background: #ffffff; overflow: hidden; }
        #network-container { width: 100vw; height: 100vh; }
        
        #ui-overlay {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.9); padding: 15px;
            border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 260px;
        }

        #timer-container {
            margin-bottom: 15px; padding: 12px; background: #2c3e50; 
            color: white; border-radius: 6px; text-align: center;
        }

        #property-panel {
            position: fixed; top: 0; right: 0; width: 500px; height: 100%; 
            background: white; border-left: 1px solid #ccc; padding: 20px; 
            overflow-y: auto; z-index: 1000; display: none; box-shadow: -5px 0 15px rgba(0,0,0,0.05);
        }
        
        /* --- CONSOLE STYLES --- */
        #console-panel {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 400px;
            background: #121212; color: #d4d4d4; font-family: 'Consolas', monospace;
            padding: 10px; overflow-y: auto; display: none; z-index: 1500;
            border-top: 3px solid #333; box-sizing: border-box;
        }
        .log-line { font-size: 0.8rem; margin-bottom: 2px; border-bottom: 1px solid #1e1e1e; white-space: pre-wrap; }
        .log-ts { color: #858585; margin-right: 10px; }
        .btn-console { background: #34495e !important; color: white !important; border: none !important; }

        .legend-item { display: flex; align-items: center; margin-bottom: 5px; font-size: 0.85rem; }
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 10px; border: 1px solid #999; }
        pre { background: #f8f8f8; padding: 10px; border-radius: 4px; font-size: 0.75rem; white-space: pre-wrap; }
        button { cursor: pointer; padding: 8px; border-radius: 4px; border: 1px solid #ccc; background: #fff; width: 100%; margin-top: 10px; }
        button:hover { background: #f0f0f0; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h2 style="margin:0 0 10px 0; font-size: 1.1rem;">Data Processing Monitor</h2>
        
        <div id="timer-container">
            <div style="font-size: 0.65rem; text-transform: uppercase; opacity: 0.7; letter-spacing: 1px;">Elapsed Time</div>
            <div id="timer-val" style="font-size: 1.6rem; font-weight: bold; font-family: 'Courier New', monospace;">00:00</div>
            <div id="total-time" style="font-size: 0.75rem; color: #18bc9c; margin-top: 4px; display: none; font-weight: bold;">Final: <span></span></div>
        </div>

        <div id="last-sync" style="font-size: 0.7rem; color: #888; margin-bottom: 12px;">Waiting for data...</div>
        
        <div class="legend">
            <div class="legend-item"><span class="dot" style="background: #0b7a39;"></span> Processed</div>
            <div class="legend-item"><span class="dot" style="background: #FFA500;"></span> Processing (Active)</div>
            <div class="legend-item"><span class="dot" style="background: #FEE245;"></span> Unprocessed</div>
            <div class="legend-item"><span class="dot" style="background: #ec0a0a;"></span> Failed</div>
        </div>
        <button onclick="network.fit()">Center View</button>
        <button class="btn-console" onclick="toggleConsole()">Toggle Console Logs</button>
    </div>

    <div id="console-panel">
        <div id="log-content"></div>
    </div>

    <div id="property-panel">
        <button style="width: auto; float: right;" onclick="document.getElementById('property-panel').style.display='none'">Ã—</button>
        <h3 id="prop-title">Node Metadata</h3>
        <pre id="prop-content"></pre>
    </div>

    <div id="network-container"></div>

    <script type="text/javascript">
        const nodes = new vis.DataSet([]);
        const edges = new vis.DataSet([]);
        const container = document.getElementById('network-container');

        const statusColors = {
            "processed": "#0b7a39",
            "processing": "#FFA500",
            "unprocessed": "#FEE245",
            "failed": "#ec0a0a"
        };

        let colorStep = 0;
        let serverStartTime = null;
        let finalDuration = null;
        let lastLogIndex = 0;

        function toggleConsole() {
            const panel = document.getElementById('console-panel');
            const isHidden = window.getComputedStyle(panel).display === 'none';
            
            panel.style.display = isHidden ? 'block' : 'none';

            if (isHidden) {
                setTimeout(() => {
                    panel.scrollTop = panel.scrollHeight;
                }, 10);
            }
        }

        // --- COLOR PULSE LOGIC ---
        function lerpColor(color1, color2, factor) {
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);
            const r = Math.round(r1 + factor * (r2 - r1));
            const g = Math.round(g1 + factor * (g2 - g1));
            const b = Math.round(b1 + factor * (b2 - b1));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function pulseProcessingNodes() {
            colorStep += 0.5;
            const factor = (Math.sin(colorStep) + 1) / 2; 
            const currentColor = lerpColor("#FFA500", "#FFFFFF", factor); // Orange to White pulse
            const processingNodes = nodes.get({ filter: (item) => item.raw && item.raw.status === 'processing' });
            
            const updates = processingNodes.map(node => ({
                id: node.id,
                color: { background: currentColor, border: "#333" }
            }));
            if (updates.length > 0) nodes.update(updates);
        }

        // --- TIMER LOGIC ---
        function updateGlobalTimer() {
            if (!serverStartTime) return;
            const allNodes = nodes.get();
            const isStillWorking = allNodes.some(n => n.raw.status === 'processing' || n.raw.status === 'unprocessed');

            let displaySeconds = finalDuration ? finalDuration : Math.max(0, Math.floor((Date.now() - serverStartTime) / 1000));

            const hrs = Math.floor(displaySeconds / 3600);
            const mins = Math.floor((displaySeconds % 3600) / 60);
            const secs = displaySeconds % 60;

            const formatted = (hrs > 0 ? hrs + ":" : "") + 
                              mins.toString().padStart(2, '0') + ":" + 
                              secs.toString().padStart(2, '0');

            const timerElement = document.getElementById('timer-val');
            timerElement.innerText = formatted;

            if (!isStillWorking && allNodes.length > 0 && !finalDuration) {
                finalDuration = displaySeconds;
                document.getElementById('total-time').style.display = 'block';
                document.getElementById('total-time').querySelector('span').innerText = formatted;
                timerElement.style.color = "#18bc9c";
            }
        }

        // --- DATA PARSING ---
        function parsePipelineData(node, nodesArray, edgesArray) {
            nodesArray.push({
                id: node.urn,
                label: node.title || node.name,
                title: `Name: ${node.title}\nType: ${node.node_type}\nStatus: ${node.status.toUpperCase()}`,
                color: { background: statusColors[node.status] || "#efefef", border: "#BBB" },
                font: { size: 40, face: 'Arial Narrow' },
                raw: node 
            });

            if (node.children) {
                node.children.forEach(child => {
                    edgesArray.push({ from: node.urn, to: child.urn, arrows: 'to', color: { color: '#999' } });
                    parsePipelineData(child, nodesArray, edgesArray);
                });
            }
        }

        async function updateGraph() {
            try {
                const response = await fetch(`/nodes?last_index=${lastLogIndex}`);
                const rawData = await response.json();
                
                // 1. Sync Timer
                if (rawData.process_started) {
                    serverStartTime = new Date(rawData.process_started).getTime();
                }

                // 2. Handle Logs
                if (rawData.logs && rawData.logs.length > 0) {
                    const logContent = document.getElementById('log-content');
                    const panel = document.getElementById('console-panel');

                    rawData.logs.forEach(log => {
                        const line = document.createElement('div');
                        line.className = 'log-line';
                        
                        // Pick colors based on module names in your logs
                        let msgColor = "#d4d4d4";
                        if (log.msg.includes("OpenSiteDownloader")) msgColor = "#d88bf0";
                        if (log.msg.includes("OpenSiteSpatial")) msgColor = "#ce9178";
                        if (log.msg.includes("[amalgamate]")) msgColor = "#569cd6";
                        if (log.msg.includes("[postprocess]")) msgColor = "#2d9c33";
                        if (log.msg.includes("OpenSiteOutput")) msgColor = "#6078e0";
                        if (log.msg.includes("OpenSitePostGIS")) msgColor = "#f5b547";

                        line.innerHTML = `<span class="log-ts">${log.time}</span><span style="color:${msgColor}">${log.msg}</span>`;
                        logContent.appendChild(line);
                    });

                    lastLogIndex = rawData.next_index;
                    panel.scrollTop = panel.scrollHeight; // Auto-scroll
                }

                // 3. Update Graph
                const tempNodes = [];
                const tempEdges = [];
                if (rawData.children && rawData.children.length > 0) {
                    rawData.children.forEach(branch => parsePipelineData(branch, tempNodes, tempEdges));
                } else if (rawData.name) {
                    parsePipelineData(rawData, tempNodes, tempEdges);
                }

                nodes.update(tempNodes);
                edges.update(tempEdges);
                document.getElementById('last-sync').innerText = "Last Sync: " + new Date().toLocaleTimeString();
            } catch (error) { console.error("API Error:", error); }
        }

        const options = {
            nodes: { shape: 'dot', size: 300 },
            edges: { smooth: false, width: 2, color: { 
                color: '#D3D3D3', 
                highlight: '#848484', 
                hover: '#848484' 
            }, arrows: { to: { enabled: true, scaleFactor: 10 } } },
            layout: { hierarchical: { enabled: true, direction: "UD", sortMethod: "directed", levelSeparation: 3000, nodeSpacing: 900, treeSpacing: 800 } },
            physics: { enabled: false },
            interaction: { dragNodes: true, hover: true }
        };

        const network = new vis.Network(container, { nodes, edges }, options);
        network.once("afterDrawing", () => setTimeout(() => network.setOptions({ layout: { hierarchical: false } }), 1000));

        network.on("click", (params) => {
            if (params.nodes.length > 0) {
                const node = nodes.get(params.nodes[0]);
                const metadata = { ...node.raw }; delete metadata.children;
                document.getElementById('property-panel').style.display = 'block';
                document.getElementById('prop-title').innerText = node.label;
                document.getElementById('prop-content').innerText = JSON.stringify(metadata, null, 2);
            }
        });

        updateGraph().then(() => setTimeout(() => network.fit(), 500));
        setInterval(updateGraph, 5000);
        setInterval(pulseProcessingNodes, 500);
        setInterval(updateGlobalTimer, 1000);

    </script>
</body>
</html>